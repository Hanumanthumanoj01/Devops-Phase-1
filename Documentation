Developer â†’ Docker â†’ GitHub â†’ GitHub Actions â†’ Docker Hub â†’ Render â†’ Monitoring

Step 1: Build Flask App

File: app.py

import os
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "ğŸš€ Hello from my DevOps Project!"

@app.route("/healthz")
def health():
    return "OK", 200

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))  # Render uses $PORT
    app.run(host="0.0.0.0", port=port)


File: requirements.txt

flask==2.2.5
gunicorn==21.2.0


ğŸ‘‰ Why

Flask is our web framework.

healthz route helps monitoring.

We use os.environ.get("PORT") because Render provides a port dynamically.

gunicorn is a production-ready server (Flask built-in server is only for dev).

ğŸ‘‰ What happened
You now have a working app that can run locally and in cloud.

ğŸ”¹ Step 2: Run Locally
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python app.py


Open http://127.0.0.1:5000
.

ğŸ‘‰ Why
To test functionality before adding Docker or deployment.

ğŸ”¹ Step 3: Dockerize App

File: Dockerfile

FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["gunicorn", "-b", "0.0.0.0:5000", "app:app"]


ğŸ‘‰ Why

Docker creates a consistent environment (Python, dependencies, code).

Any machine/container can run this app the same way.

Build & Run

docker build -t flask-devops-app .
docker run -p 5000:5000 flask-devops-app


ğŸ‘‰ Open http://localhost:5000
.

ğŸ”¹ Step 4: Push Code to GitHub
git init
git add .
git commit -m "First commit"
git branch -M main
git remote add origin https://github.com/<your-username>/flask-devops-project.git
git push -u origin main


ğŸ‘‰ Why

GitHub is our version control & CI/CD trigger.

Every push â†’ pipeline runs.

ğŸ”¹ Step 5: GitHub Actions (CI/CD)

File: .github/workflows/ci-cd.yml

name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Docker
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build & Push Docker image
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/flask-devops-app:latest .
          docker push ${{ secrets.DOCKER_USERNAME }}/flask-devops-app:latest


ğŸ‘‰ Secrets in GitHub

DOCKER_USERNAME = your Docker Hub username (ex: mhanumanthu)

DOCKER_PASSWORD = your Docker Personal Access Token

ğŸ‘‰ Why

This pipeline automates:

Build Docker image

Push to Docker Hub

No manual builds needed.

ğŸ‘‰ What happened
Every git push â†’ GitHub builds & stores your image in Docker Hub.

ğŸ”¹ Step 6: Deploy on Render

Sign up at Render
 (free).

New Web Service â†’ Connect your GitHub repo.

Settings:

Build Command:
pip install -r requirements.txt


Start Command:

gunicorn app:app


Instance Type: Free tier.

ğŸ‘‰ Why

Render gives free hosting for web apps.

It auto-builds & deploys when you push to GitHub.

ğŸ‘‰ What happened
Your Flask app is live at a free Render URL (e.g. https://flask-devops-app.onrender.com).

ğŸ”¹ Step 7: Monitoring Script

File: monitor.py

import requests, time

URL = "https://flask-devops-app.onrender.com"

while True:
    try:
        response = requests.get(URL)
        if response.status_code == 200:
            print("âœ… App is UP")
        else:
            print("âš ï¸ Status:", response.status_code)
    except Exception as e:
        print("âŒ App is DOWN:", e)
    time.sleep(10)


ğŸ‘‰ Why

Basic uptime monitoring.

Demonstrates DevOps monitoring skill.